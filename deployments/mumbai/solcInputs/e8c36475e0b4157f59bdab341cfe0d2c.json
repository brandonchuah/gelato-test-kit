{
  "language": "Solidity",
  "sources": {
    "contracts/vrf/base/GelatoVRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IGelatoVRFConsumer} from \"./IGelatoVRFConsumer.sol\";\n\n/// @title GelatoVRFConsumerBase\n/// @dev This contract handles domain separation between consecutive randomness requests\n/// The contract has to be implemented by contracts willing to use the gelato VRF system.\n/// This base contract enhances the GelatoVRFConsumer by introducing request IDs and\n/// ensuring unique random values.\n/// for different request IDs by hashing them with the random number provided by drand.\n/// For security considerations, refer to the Gelato documentation.\nabstract contract GelatoVRFConsumerBase is IGelatoVRFConsumer {\n    bool[] public requestPending;\n    mapping(uint64 requestId => bytes32 requestHash) public requestedHash;\n\n    /// @notice Returns the address of the dedicated msg.sender.\n    /// @dev The operator can be found on the Gelato dashboard after a VRF is deployed.\n    /// @return Address of the operator.\n    function _operator() internal view virtual returns (address);\n\n    /// @notice Requests randomness from the Gelato VRF.\n    /// @dev The extraData parameter allows for additional data to be passed to\n    /// the VRF, which is then forwarded to the callback. This is useful for\n    /// request tracking purposes if requestId is not enough.\n    /// @param extraData Additional data for the randomness request.\n    /// @return requestId The ID for the randomness request.\n    function _requestRandomness(\n        bytes memory extraData\n    ) internal returns (uint64 requestId) {\n        requestId = uint64(requestPending.length);\n        requestPending.push();\n        requestPending[requestId] = true;\n\n        bytes memory data = abi.encode(requestId, extraData);\n        // solhint-disable-next-line not-rely-on-time\n        bytes memory dataWithTimestamp = abi.encode(data, block.timestamp);\n        bytes32 requestHash = keccak256(dataWithTimestamp);\n\n        requestedHash[requestId] = requestHash;\n\n        emit RequestedRandomness(data);\n    }\n\n    /// @notice User logic to handle the random value received.\n    /// @param randomness The random number generated by Gelato VRF.\n    /// @param requestId The ID for the randomness request.\n    /// @param extraData Additional data from the randomness request.\n    function _fulfillRandomness(\n        uint256 randomness,\n        uint64 requestId,\n        bytes memory extraData\n    ) internal virtual;\n\n    /// @notice Callback function used by Gelato VRF to return the random number.\n    /// The randomness is derived by hashing the provided randomness with the request ID.\n    /// @param randomness The random number generated by Gelato VRF.\n    /// @param dataWithTimestamp Additional data provided by Gelato VRF containing request details.\n    function fulfillRandomness(\n        uint256 randomness,\n        bytes calldata dataWithTimestamp\n    ) external {\n        require(msg.sender == _operator(), \"only operator\");\n\n        (bytes memory data, ) = abi.decode(dataWithTimestamp, (bytes, uint256));\n        (uint64 requestId, bytes memory extraData) = abi.decode(\n            data,\n            (uint64, bytes)\n        );\n\n        bytes32 requestHash = keccak256(dataWithTimestamp);\n        bool isValidRequestHash = requestHash == requestedHash[requestId];\n\n        if (requestPending[requestId] && isValidRequestHash) {\n            randomness = uint(\n                keccak256(\n                    abi.encode(\n                        randomness,\n                        address(this),\n                        block.chainid,\n                        requestId\n                    )\n                )\n            );\n\n            _fulfillRandomness(randomness, requestId, extraData);\n            requestPending[requestId] = false;\n        }\n    }\n}\n"
    },
    "contracts/vrf/base/IGelatoVRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IGelatoVRFConsumer\n/// @dev Interface for consuming random number provided by Drand.\n/// @notice This interface allows contracts to receive a random number provided by Gelato VRF.\ninterface IGelatoVRFConsumer {\n    /// @notice Event emitted when a randomness request is made.\n    /// @param data Additional data associated with the request.\n    event RequestedRandomness(bytes data);\n\n    /// @notice Callback function used by Gelato to return the random number.\n    /// @dev The random number is fetched from one among many drand endpoints\n    /// and passed back to this function like in a Gelato Web3 Function.\n    /// @param randomness The random number generated by drand.\n    /// @param data Additional data provided by Gelato VRF or the user, typically unused.\n    function fulfillRandomness(\n        uint256 randomness,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/vrf/GelatoVRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GelatoVRFConsumerBase} from \"./base/GelatoVRFConsumerBase.sol\";\n\ncontract GelatoVRFConsumer is GelatoVRFConsumerBase {\n    struct Request {\n        uint256 requestTime;\n        uint256 requestBlock;\n        uint256 fulfilledTime;\n        uint256 fulfilledBlock;\n        uint256 randomness;\n    }\n\n    event RandomnessFulfilled(\n        uint256 indexed nonce,\n        uint256 indexed fulfilledCount,\n        Request request\n    );\n\n    address public immutable dedicatedMsgSender;\n    uint256 public nonce;\n    mapping(uint256 => mapping(uint256 => Request)) public requests;\n    mapping(uint256 => uint256) public nonceFulfilledCount;\n\n    constructor(address _dedicatedMsgSender) {\n        dedicatedMsgSender = _dedicatedMsgSender;\n    }\n\n    function _operator() internal view override returns (address) {\n        return dedicatedMsgSender;\n    }\n\n    function requestRandomness(uint256 _count) external {\n        for (uint256 i; i < _count; i++) {\n            _requestRandomness(\n                abi.encode(nonce, block.timestamp, block.number)\n            );\n        }\n        nonce += 1;\n    }\n\n    function _fulfillRandomness(\n        uint256 _randomness,\n        uint64,\n        bytes memory _extraData\n    ) internal override {\n        (uint256 nonce_, uint256 requestTime, uint256 requestBlock) = abi\n            .decode(_extraData, (uint256, uint256, uint256));\n\n        Request memory request = Request(\n            requestTime,\n            requestBlock,\n            block.timestamp,\n            block.number,\n            _randomness\n        );\n\n        uint256 fulfilledCount = nonceFulfilledCount[nonce_];\n        uint256 newFulfilledCount = fulfilledCount + 1;\n\n        requests[nonce_][fulfilledCount] = request;\n        nonceFulfilledCount[nonce_] = newFulfilledCount;\n\n        emit RandomnessFulfilled(nonce_, newFulfilledCount, request);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}